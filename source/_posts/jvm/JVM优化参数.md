---
layout: '[layout]'
title: JVM优化参数
date: 2018/5/21 16:04:21 
categories: 后端
tags: [JVM]
---
### -server：开启服务端模式。
1. -client、-server这两个参数用于设置虚拟机使用何种运行模式，client模式启动比较快，但运行时性能和内存管理效率不如server模式，通常用于客户端应用程序。相反，server模式启动比client慢，但可获得更高的运行性能。
2. 在 windows上，缺省的虚拟机类型为client模式，如果要使用server模式，就需要在启动虚拟机时加-server参数，以获得更高性能，对服 务器端应用，推荐采用server模式，尤其是多个CPU的系统。在Linux，Solaris上缺省采用server模式。

### --XX:+UseCompressedOops：压缩普通对象指针。
1. “ordinary object pointer” 普通对象指针。在64位HotSpot中使用32位指针，默认64位会比32位的内存使用多出1.5倍
2. 启用CompressOops后，会压缩的对象：
	* 每个Class的属性指针（静态成员变量）
	* 每个对象的属性指针
	* 普通对象数组的每个元素指针

比如指向PermGen的Class对象指针、本地变量、堆栈元素、入参、返回值、NULL指针不会被压缩。
2. 这就是面对对象的好处，我们面对的最小地址单元不是byte，而是object，也就是说在jvm的世界里32位地址表示的不是4GB，而是4G个对象的指针，大概是32GB，解码过程就是把对象指针乘以8加上GC堆的初始地址就能得到操作系统本地64位地址了，编码过程相反。
其中启用压指得有操作系统底层的支持：GC堆从虚拟地址0开始分配
进而我们可以得到压指面对的所有场景：
	* 如果GC堆大小在4G以下，直接砍掉高32位，避免了编码解码过程
	* 如果GC堆大小在4G以上32G以下，则启用UseCompressedOop
	* 如果GC堆大小大于32G，压指失效（所以说服务器内存太大不好......）

### -Xloggc：<file>：垃圾回收日志
1. JVM的GC日志的主要参数包括如下几个：
	* -XX:+PrintGC：输出GC日志
	* -XX:+PrintGCDetails： 输出GC的详细日志
	* -XX:+PrintGCTimeStamps：输出GC的时间戳（以基准时间的形式）
	* -XX:+PrintGCDateStamps：输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）
	* -XX:+PrintHeapAtGC：在进行GC的前后打印出堆的信息
	* -Xloggc:../logs/gc.log：日志文件的输出路径
2. 将虚拟机每次垃圾回收的信息写到日志文件中，文件名由file指定，文件格式是平文件，内容和-verbose:gc输出内容相同。

### -Xms<size>：初始堆内存
设置虚拟机可用内存堆的初始大小，缺省单位为字节，该大小为1024的整数倍并且要大于1MB，可用k(K)或m(M)为单位来设置较大的内存数。初始堆大小为2MB。
例如：-Xms6400K，-Xms256M

### -Xmx<size>：最大堆内存
设置虚拟机内存堆的最大可用大小，缺省单位为字节。该值必须为1024整数倍，并且要大于2MB。可用k(K)或m(M)为单位来设置较大的内存数。缺省堆最大值为64MB。
例如：-Xmx81920K，-Xmx80M

### -Xmn<size>：新生代内存大小
-Xmn用来设置堆内新生代的大小。通过这个值我们也可以得到老生代的大小：-Xmx减去-Xmn

### -Xss<size>：栈深度
-Xss设置每个线程可使用的内存大小。
在相同物理内存下，减小这个值能生成更多的线程。当然操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。

